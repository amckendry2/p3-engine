#include "sprite.h"
#include "pixel_canvas.h"
#include "utils.h"
#include <math.h>
#include <map>
#include <vector>
#include <string>
#include <filesystem>
#include <fstream>
#include <regex>
#include <SDL2/SDL_image.h>

using namespace std;


PixelCanvas::PixelCanvas(){
    mRenderer = NULL;
    mTexture = NULL;
    mappingFormat = NULL;
    pixelWidth = 0;
    pixelHeight = 0;
    bufferLength = 0;
    pixelBuffer = NULL;
    transparentColor = NULL;
};

PixelCanvas::~PixelCanvas(){ free(); }

bool PixelCanvas::init(SDL_Renderer* renderer, SDL_Window* window, int w, int h){
    mRenderer = renderer;
    mTexture = SDL_CreateTexture(mRenderer, SDL_GetWindowPixelFormat(window), SDL_TEXTUREACCESS_STATIC, w, h);
    Uint32 format;
    SDL_QueryTexture(mTexture, &format, nullptr, &pixelWidth, &pixelHeight);
    mappingFormat = SDL_AllocFormat(format);
    pixelBuffer = new Uint32[pixelWidth * pixelHeight];
    bufferLength = pixelWidth * pixelHeight;
    bufferPitch = pixelWidth * sizeof(Uint32);
    transparentColor = SDL_MapRGBA(mappingFormat, 0, 0, 0, 255);
    return mTexture != NULL;
}

void PixelCanvas::free(){
    if(mappingFormat != NULL){
	SDL_FreeFormat(mappingFormat);
	mappingFormat = NULL;
    }
    if(mTexture != NULL){
	SDL_DestroyTexture(mTexture);
	mTexture = NULL;
    }
    delete[](pixelBuffer);
    pixelBuffer = NULL;
}

void PixelCanvas::render(){
    SDL_UpdateTexture(mTexture, NULL, pixelBuffer, bufferPitch);
    SDL_RenderCopy(mRenderer, mTexture, NULL, NULL);
}

void PixelCanvas::setTransparentColor(SDL_Color color){
    transparentColor = SDL_MapRGBA(mappingFormat, color.r, color.g, color.b, color.a);
}

void PixelCanvas::clear(SDL_Color color){
    Uint32 colorType = SDL_MapRGBA(mappingFormat, color.r, color.g, color.b, color.a);
    for(int i = 0; i < bufferLength; i++){
        pixelBuffer[i] = colorType;
    }
}

void PixelCanvas::pset(int x, int y, SDL_Color color){
    int i = y * pixelWidth + x;
    Uint32 colorType = SDL_MapRGBA(mappingFormat, color.r, color.g, color.b, color.a);
    pixelBuffer[i] = colorType;
}

void PixelCanvas::spr(string spriteName, int index, int x0, int y0){
    vector<Sprite> spriteVec = spriteLibrary[spriteName];
    Sprite spr = spriteVec[index];
    for (int i = 0; i < spr.width * spr.height; i++){
	Uint32 pixel = spr.rgbaVec[i];
	if(!compareRGBA(pixel, transparentColor, mappingFormat)){
	    int x = i % spr.width;
	    int y = floor(i / spr.width);
	    int i = (y0 + y) * pixelWidth + x0 + x;
	    pixelBuffer[i] = pixel;
	}
        
    }
    
}

void PixelCanvas::loadSpriteLibrary(string dirPath){
    regex wPat {R"(w=([\d+]))"};
    regex hPat {R"(h=([\d+]))"};
    for(auto& p : filesystem::recursive_directory_iterator(dirPath)){
	if(p.path().extension() == ".png"){
	    string fileName = p.path().filename().replace_extension("");
	    string cfgPath = dirPath + "/" + fileName + ".cfg"; 
	    ifstream cfgFile;
	    string line;
	    cfgFile.open(cfgPath);
	    if(cfgFile.is_open()){
		int sprWidth = NULL;
		int sprHeight = NULL;
		while(getline(cfgFile, line)){
		    smatch matches;
		    if(regex_search(line, matches, wPat)){
			sprWidth = stoi(matches[1]);
		    } else if(regex_search(line, matches, hPat)){
			sprHeight = stoi(matches[1]);
		    }
		}
		if(sprWidth != NULL && sprHeight != NULL){
		    vector<Sprite> sprvec;
		    SDL_Surface* imgSurface = IMG_Load(p.path().c_str());
		    SDL_Surface* sprSurface = SDL_CreateRGBSurface(0, sprWidth, sprHeight, 32, 0, 0, 0, 0);
		    for(int x = 0; x < imgSurface->w; x+=sprWidth){
			for(int y = 0; y < imgSurface->h; y+=sprHeight){
			    SDL_Rect frame = {x, y, sprWidth, sprHeight};
			    SDL_BlitSurface(imgSurface, &frame, sprSurface, NULL);
			    Sprite spr(sprSurface, mappingFormat->format);
			    sprvec.push_back(move(spr));
			}
		    }		    
		    spriteLibrary.insert(pair<string,vector<Sprite>>(fileName, sprvec));
		    SDL_FreeSurface(imgSurface);
		    SDL_FreeSurface(sprSurface);
		}
	    }
	}
    }
}


